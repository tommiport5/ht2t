
/**
 * postProcess
 * the raw list according to the rules determined by NodeType::H :
 * ignore: 	this node is completely ignored
 * skip:	this node is made a top node, all other nodes until its end node are made children of him
 * embed:	this node is made a child of the current top node
 * stop:	this node is made the new current top node
 *
 * TODO: Check for start and end of the nodes
 */
void Node::postProcess(std::list<Node>::iterator &currentTop, std::list<Node>::iterator &n, std::list<Node> &lst)
{
	NodeType cnt = n->_nt;
	switch(n->_nt.Hnd()) {
	case NodeType::discard:
		++n;
		break;
	case NodeType::skip:
		while (!((++n)->_nt == cnt)){
			if (n == lst.end()) break;
		}
		break;
	case NodeType::stop:
		currentTop = n++;
		break;
	case NodeType::embed:
		currentTop->nested.push_back(*n);
		n = lst.erase(n);
		break;
	}
}


string &&Node::completeNode(const std::string &text, list<Node>::const_iterator &n, list<Node>::const_iterator end) const
{
	static string res;

	if (n!= end) {
		list<Node>::const_iterator p = n;
		list<Node>::const_iterator last = p;

		++p;
		while (p != end) {
			if (p->getTyp() == n->getTyp()) {
				// Node ends here, or new node of same type starts, in which case we end the old one automatically (and silently),
				// because this is a frequent programming error for web authors
				int StartOfString = last->_start + last->_raw.length();
				res += text.substr(StartOfString, p->_start - StartOfString);
				//++p;
				break;
			} else {
				// in all other cases, we just merge the text and continue
				int StartOfString = last->_start + last->_raw.length();
				res += text.substr(StartOfString, p->_start - StartOfString);
				last = p;
				++p;
			}
		}
		n = p;
	}
	return move(res);
}


string Node::extractText(const string &text, list<Node>::const_iterator n) const
{
	string res;
	list<Node>::const_iterator last = n;


	if (nested.empty()) {
		++n;
		int StartOfString = last->_start + last->_raw.length();
		res = text.substr(StartOfString, n->_start - StartOfString);
	} else {
		Node &t = const_cast<Node &>(*n);
		for_each(last->nested.begin(), last->nested.end(), [text, &res, &t](const Node &p){
			int StartOfString = t._start + t._raw.length();
			res += text.substr(StartOfString, p._start - StartOfString);
			t = p;
		});
		++n;
		int StartOfString = t._start + t._raw.length();
		res += text.substr(StartOfString, n->_start - StartOfString);
	}
	return res;
}


// insert Background
auto last = p;
p++;
do {
	if (p == Parsed.end()) return false;
	string tmp = Buf.substr(last->getLastPosition(), p->start() - last->getLastPosition());
	if (!emptyOrBlank(tmp)) {
		Node nn(NodeType::background, p->getLastPosition(), move(tmp), false);
		Parsed.insert(p, nn);
	}
	last = p;
	p++;
} while (!(last->getTyp() == NodeType::body));

